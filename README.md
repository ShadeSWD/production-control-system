# Система контроля заданий на выпуск продукции

Функционал системы **контроля заданий на выпуск продукции** заключается в том, чтобы получать сменные задания (партии) и уникальные идентификаторы продукции в рамках этой партии, а так же проверять (по запросу из внешней системы), принадлежит ли данный идентификатор продукции данной партии.

**Основные задачи:**

- [x] Эндпойнт добавления сменных заданий
- [x] Эндпойнт получения сменного задания по ID
- [x] Эндпойнт изменения сменного задания по ID
- [x] Эндпойнт добавления продукции для сменного задания (партии)
- [ ] Эндпойнт получения списка сменных заданий по фильтрам
- [x] Эндпойнт "агрегации" продукции

**Задачи "со звездочкой":**

- [ ] Тесты
- [ ] docker
- [ ] Базовый CI/CD

**Запуск проекта:**

Опишите, как запустить ваш проект и как запустить тесты (если они есть).

Решение нужно отправить в виде ссылки на ваш репозиторий с проектом (не забудьте сделать его публичным).

Пожалуйста, в ходе решения этой задачи постарайтесь коммитить ваши действия (а не просто отправить готовое решение одним коммитом), нам важно оценить не только ваше решение, но и как вы к нему пришли.

Нам будет особенно приятно, если вы будете использовать [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/#summary).

Если в ходе реализации возникнут какие-то вопросы, смело задавайте их в [issues](https://github.com/axon-expert/backend-test-task/issues) данного репозитория, мы на них обязательно ответим.

## Основные задачи

### Эндпойнт добавления сменных заданий

Принимает список сменных заданий в виде json.

Сменное задание состоит из следующих полей со следующими типами:

* **СтатусЗакрытия**: bool
* **ПредставлениеЗаданияНаСмену**: str
* **Рабочий центр**: str
* **Смена**: str
* **Бригада**: str
* **НомерПартии**: int
* **ДатаПартии**: date
* **Номенклатура**: str
* **КодЕКН**: str
* **ИдентификаторРЦ**: str
* **ДатаВремяНачалаСмены**: datetime
* **ДатаВремяОкончанияСмены**: datetime

Пример:
```json
[
	{
		"СтатусЗакрытия": false,
		"ПредставлениеЗаданияНаСмену": "Задание на смену 2345",
		"РабочийЦентр": "Т2",
		"Смена": "1",
		"Бригада": "Бригада №4",
		"НомерПартии": 22222,
		"ДатаПартии": "2024-01-30",
		"Номенклатура": "Какая то номенклатура",
		"КодЕКН": "456678",
		"ИдентификаторРЦ": "A",
		"ДатаВремяНачалаСмены": "2024-01-30T20:00:00+05:00",
		"ДатаВремяОкончанияСмены": "2024-01-31T08:00:00+05:00"
	}
]
```

У сменного задания помимо поля ``СтатусЗакрытия`` создается поле ``closed_at`` (время закрытия), которое выставляется при закрытии партии (если она еще открыта, то это поле имеет значение ``null``). Так же у сменного задания есть внутренний id (``primary key``), по которому можно получить информацию о конкретном сменном задании, либо же изменить ее (например, закрыть сменное задание).

Пара НомерПартии и ДатаПартии всегда уникальна! Если уже существует какая-то партия с аналогичным номером партии и датой партии, она будет перезаписана.

### Эндпойнт получения сменного задания (партии) по ID (``primary key``).
Данный эндпойнт должен возвращает json со сменным заданием по его внутреннему ID вместе со списком уникальных кодов продукции, привязанных к этой партии.

Если сменного задания с данным ID нет, возвращается ошибка 404.

### Эндпойнт изменения сменного задания (партии) по ID (``primary key``).
Данный эндпойнт позволяет изменить одно или несколько полей. Если сменного задания с данным ID нет, то возвращает 404 ошибку.

Если статус закрытия партии меняется на ``True``, то в ``closed_at`` выставляется текущий ``datetime``, а если наоборот -- то ``null``.

В качестве респонса возвращает json обновленной партии.

### Эндпойнт получения сменных заданий по различным фильтрам 

Данный эндпойнт возвращает json со списком сменных заданий по различным фильтрам (СтатусЗакрытия, НомерПартии, ДатаПартии).

### Эндпойнт добавления продукции для сменного задания (партии).

Данный эндпойнт получает из корпоративной системы заказчика список уникальных кодов продукции и сменных заданий (НомерПартии и ДатаПартии), к которому данный код продукции **привязан**.

Пример:
```json
[
	{
		"УникальныйКодПродукта": "12gRV60MMsn1",
		"НомерПартии": 22222,
		"ДатаПартии": "2024-01-30"
	},
	{
		"УникальныйКодПродукта": "12gRV60MMsn2",
		"НомерПартии": 33333,
		"ДатаПартии": "2024-01-31"
	}
]
```

Сохраняется уникальный код продукции с привязкой к партии. Дополнительно к коду добавляются поля ``is_aggregated`` (bool поле, был ли данный уникальный код продукции уже агрегирован) и ``aggregated_at`` (datetime, когда была агрегирована продукция с данным уникальным кодом). Если продукция передана с несуществующей партией (нет сменного задания с указанным номером партии и датой партии), то данную продукция игнорируется.

Если переданная продукция с данным уникальным кодом уже существует, она игнорируется.

### Эндпойнт "агрегации" продукции.
Данный эндпойнт принимает ID партии (``primary key``) и уникальный код продукции. Если данный уникальный код продукции существует и привязан к партии с данным ID, и при этом данный уникальный код продукции не был использован (агрегирован), то ``is_aggregated`` изменяется на true и ``aggregated_at`` на текущий ``datetime``. Возвращается уникальный код в виде json-а.

Если данный уникальный код уже был использован, то возвращается 400 ошибка с описанием: "unique code already used at {aggregated_at}".

Если уникальный код существует, но привязан к другой партии, возвращается 400 ошибка с описанием: "unique code is attached to another batch".

Если продукции с данным уникальным кодом не существует, то необходимо вернуть 404 ошибку.

Формат входных данных выбираете вы сами.

## Задания "со звездочкой"

### Добавить тесты (unit, functional, integration)

### Использовать контейнеризацию (docker)

### Базовый CI/CD
Используя ``Github actions``:
1. Добавить проверку кода линтерами (mypy, flake8) и форматерами (black, isort). Вместо flake8, isort и black можно использовать ruff.
2. Добавить запуск тестов (если есть).
3. Добавить сборку проекта в docker образ и отправку этого образа в docker hub или github container registry.
